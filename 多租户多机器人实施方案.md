# ğŸ¤– å¤šç§Ÿæˆ·å¤šæœºå™¨äººå®æ–½æ–¹æ¡ˆ

## ğŸ“Š æ¶æ„è®¾è®¡

### å½“å‰æ¶æ„ vs ç›®æ ‡æ¶æ„

```mermaid
graph TB
    subgraph "å½“å‰æ¶æ„ - å•æœºå™¨äºº"
        A1[å•ä¸ªBot Token] --> B1[Botè¿›ç¨‹]
        B1 --> C1[å¤šä¸ªç®¡ç†å‘˜å…±ç”¨]
    end
    
    subgraph "ç›®æ ‡æ¶æ„ - å¤šæœºå™¨äºº"
        A2[ç§Ÿæˆ·A - Bot Token A] --> B2[Webhookè·¯ç”±]
        A3[ç§Ÿæˆ·B - Bot Token B] --> B2
        A4[ç§Ÿæˆ·C - Bot Token C] --> B2
        B2 --> C2[ç§Ÿæˆ·Aæ•°æ®]
        B2 --> C3[ç§Ÿæˆ·Bæ•°æ®]
        B2 --> C4[ç§Ÿæˆ·Cæ•°æ®]
    end
```

## ğŸ¯ å®æ–½æ–¹æ¡ˆï¼šWebhookæ¨¡å¼ï¼ˆæ¨èï¼‰

### æ–¹æ¡ˆä¼˜åŠ¿

âœ… **å•è¿›ç¨‹æ”¯æŒæ— é™æœºå™¨äºº**  
âœ… **èµ„æºå ç”¨ä½**ï¼ˆä¸€ä¸ªDjangoè¿›ç¨‹å³å¯ï¼‰  
âœ… **æ˜“äºæ‰©å±•**ï¼ˆæ–°å¢ç§Ÿæˆ·æ— éœ€é‡å¯ï¼‰  
âœ… **ä¾¿äºç›‘æ§**ï¼ˆç»Ÿä¸€æ—¥å¿—å’Œç®¡ç†ï¼‰  
âœ… **æˆæœ¬ä½**ï¼ˆé€‚åˆå•†ä¸šåŒ–SaaSï¼‰

### æ ¸å¿ƒæ€è·¯

1. **æ•°æ®åº“å­˜å‚¨**ï¼šæ¯ä¸ªç§Ÿæˆ·ä¿å­˜è‡ªå·±çš„`bot_token`
2. **Webhookè·¯ç”±**ï¼šæ ¹æ®è¯·æ±‚çš„bot_tokenåŠ¨æ€è·¯ç”±åˆ°ä¸åŒç§Ÿæˆ·
3. **æ•°æ®éš”ç¦»**ï¼šåŸºäº`admin_user`åŒºåˆ†æ•°æ®
4. **åŠ¨æ€æ³¨å†Œ**ï¼šç§Ÿæˆ·æ·»åŠ tokenåè‡ªåŠ¨æ³¨å†Œwebhook

## ğŸ“‹ å®æ–½æ­¥éª¤

### ç¬¬ä¸€æ­¥ï¼šæ•°æ®æ¨¡å‹æ‰©å±•

åœ¨`User`æ¨¡å‹ä¸­æ·»åŠ æœºå™¨äººé…ç½®å­—æ®µï¼ˆé€šè¿‡Profileæ‰©å±•ï¼‰

```python
# models.py

class UserProfile(models.Model):
    """ç”¨æˆ·é…ç½®æ–‡ä»¶ - æ‰©å±•Useræ¨¡å‹"""
    user = models.OneToOneField(
        User,
        on_delete=models.CASCADE,
        related_name='profile',
        verbose_name='ç”¨æˆ·'
    )
    
    # æœºå™¨äººé…ç½®
    bot_token = models.CharField(
        max_length=255,
        blank=True,
        null=True,
        verbose_name='Bot Token',
        help_text='ä» @BotFather è·å–çš„æœºå™¨äººToken'
    )
    
    bot_username = models.CharField(
        max_length=100,
        blank=True,
        null=True,
        verbose_name='æœºå™¨äººç”¨æˆ·å',
        help_text='ä¾‹å¦‚ï¼š@MyLotteryBot'
    )
    
    webhook_enabled = models.BooleanField(
        default=False,
        verbose_name='Webhookå·²å¯ç”¨',
        help_text='æ˜¯å¦å·²æˆåŠŸæ³¨å†ŒWebhook'
    )
    
    webhook_url = models.URLField(
        blank=True,
        null=True,
        verbose_name='Webhook URL',
        help_text='Telegram Webhookåœ°å€'
    )
    
    # ç§Ÿæˆ·ä¿¡æ¯
    company_name = models.CharField(
        max_length=200,
        blank=True,
        verbose_name='å…¬å¸åç§°'
    )
    
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='åˆ›å»ºæ—¶é—´')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='æ›´æ–°æ—¶é—´')
    
    class Meta:
        db_table = 'user_profiles'
        verbose_name = 'ç”¨æˆ·é…ç½®'
        verbose_name_plural = verbose_name
    
    def __str__(self):
        return f"{self.user.username} - Profile"
```

### ç¬¬äºŒæ­¥ï¼šWebhookè§†å›¾å®ç°

```python
# lottery/webhook_views.py

import json
import logging
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth.models import User
from telegram import Update, Bot
from telegram.ext import Application, ContextTypes
from .models import UserProfile
from .bot_handlers import setup_handlers  # æˆ‘ä»¬éœ€è¦åˆ›å»ºè¿™ä¸ª

logger = logging.getLogger(__name__)

# å­˜å‚¨æ¯ä¸ªbotçš„Applicationå®ä¾‹
BOT_APPLICATIONS = {}


async def get_or_create_bot_application(bot_token: str):
    """è·å–æˆ–åˆ›å»ºBot Applicationå®ä¾‹"""
    if bot_token not in BOT_APPLICATIONS:
        application = Application.builder().token(bot_token).build()
        await setup_handlers(application)  # æ³¨å†Œå¤„ç†å™¨
        await application.initialize()
        BOT_APPLICATIONS[bot_token] = application
        logger.info(f"åˆ›å»ºæ–°çš„Bot Application: {bot_token[:10]}...")
    
    return BOT_APPLICATIONS[bot_token]


@csrf_exempt
async def telegram_webhook(request, bot_token):
    """
    Telegram Webhook ç»Ÿä¸€å…¥å£
    URLæ ¼å¼ï¼š/api/webhook/{bot_token}/
    """
    if request.method != 'POST':
        return HttpResponse('Method Not Allowed', status=405)
    
    try:
        # 1. éªŒè¯bot_tokenæ˜¯å¦å­˜åœ¨äºç³»ç»Ÿä¸­
        profile = UserProfile.objects.filter(bot_token=bot_token).first()
        if not profile:
            logger.warning(f"æœªæ‰¾åˆ°å¯¹åº”çš„Bot Token: {bot_token[:10]}...")
            return HttpResponse('Forbidden', status=403)
        
        # 2. è§£æTelegram Update
        update_data = json.loads(request.body.decode('utf-8'))
        logger.info(f"æ”¶åˆ°Webhookè¯·æ±‚ - ç§Ÿæˆ·: {profile.user.username}")
        
        # 3. è·å–Bot Application
        application = await get_or_create_bot_application(bot_token)
        
        # 4. å¤„ç†Updateï¼ˆä¼ å…¥user_idç”¨äºæ•°æ®éš”ç¦»ï¼‰
        update = Update.de_json(update_data, application.bot)
        
        # 5. åœ¨contextä¸­æ³¨å…¥å½“å‰ç§Ÿæˆ·ä¿¡æ¯
        context = application.context_types.context()
        context.user_data['admin_user_id'] = profile.user.id
        context.user_data['admin_username'] = profile.user.username
        
        # 6. å¤„ç†Update
        await application.process_update(update)
        
        return JsonResponse({'ok': True})
        
    except Exception as e:
        logger.error(f"å¤„ç†Webhookå¤±è´¥: {str(e)}", exc_info=True)
        return JsonResponse({'ok': False, 'error': str(e)}, status=500)


@csrf_exempt
async def register_webhook(request):
    """
    ä¸ºå½“å‰ç”¨æˆ·æ³¨å†ŒWebhook
    POST /api/bot/register-webhook/
    Body: {
        "bot_token": "your_bot_token",
        "webhook_url": "https://yourdomain.com/api/webhook/{bot_token}/"
    }
    """
    if request.method != 'POST':
        return HttpResponse('Method Not Allowed', status=405)
    
    try:
        data = json.loads(request.body.decode('utf-8'))
        bot_token = data.get('bot_token')
        webhook_url = data.get('webhook_url')
        
        if not bot_token:
            return JsonResponse({'error': 'bot_tokenå¿…å¡«'}, status=400)
        
        # è·å–æˆ–åˆ›å»ºç”¨æˆ·Profile
        profile, created = UserProfile.objects.get_or_create(user=request.user)
        
        # éªŒè¯Bot Token
        bot = Bot(token=bot_token)
        bot_info = await bot.get_me()
        
        # æ„é€ webhook URL
        if not webhook_url:
            # è‡ªåŠ¨æ„é€ ï¼ˆéœ€è¦é…ç½®åŸŸåï¼‰
            domain = request.get_host()
            webhook_url = f"https://{domain}/api/webhook/{bot_token}/"
        
        # æ³¨å†ŒTelegram Webhook
        result = await bot.set_webhook(url=webhook_url)
        
        if result:
            # ä¿å­˜é…ç½®
            profile.bot_token = bot_token
            profile.bot_username = bot_info.username
            profile.webhook_url = webhook_url
            profile.webhook_enabled = True
            profile.save()
            
            logger.info(f"Webhookæ³¨å†ŒæˆåŠŸ - ç”¨æˆ·: {request.user.username}, Bot: @{bot_info.username}")
            
            return JsonResponse({
                'ok': True,
                'message': 'Webhookæ³¨å†ŒæˆåŠŸ',
                'bot_username': bot_info.username,
                'webhook_url': webhook_url
            })
        else:
            return JsonResponse({'error': 'Webhookæ³¨å†Œå¤±è´¥'}, status=500)
            
    except Exception as e:
        logger.error(f"æ³¨å†ŒWebhookå¤±è´¥: {str(e)}", exc_info=True)
        return JsonResponse({'error': str(e)}, status=500)


@csrf_exempt
async def remove_webhook(request):
    """ç§»é™¤Webhook"""
    if request.method != 'POST':
        return HttpResponse('Method Not Allowed', status=405)
    
    try:
        profile = request.user.profile
        
        if not profile.bot_token:
            return JsonResponse({'error': 'æœªé…ç½®Bot'}, status=400)
        
        # åˆ é™¤Telegram Webhook
        bot = Bot(token=profile.bot_token)
        await bot.delete_webhook()
        
        # æ¸…é™¤é…ç½®
        profile.webhook_enabled = False
        profile.save()
        
        # ç§»é™¤Applicationç¼“å­˜
        if profile.bot_token in BOT_APPLICATIONS:
            del BOT_APPLICATIONS[profile.bot_token]
        
        logger.info(f"Webhookå·²ç§»é™¤ - ç”¨æˆ·: {request.user.username}")
        
        return JsonResponse({'ok': True, 'message': 'Webhookå·²ç§»é™¤'})
        
    except Exception as e:
        logger.error(f"ç§»é™¤Webhookå¤±è´¥: {str(e)}", exc_info=True)
        return JsonResponse({'error': str(e)}, status=500)
```

### ç¬¬ä¸‰æ­¥ï¼šBotå¤„ç†å™¨ï¼ˆæ”¯æŒå¤šç§Ÿæˆ·ï¼‰

```python
# lottery/bot_handlers.py

import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from .models import Lottery, TelegramUser, Participation
from django.utils import timezone

logger = logging.getLogger(__name__)


async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¯åŠ¨å‘½ä»¤"""
    user = update.effective_user
    
    # è·å–å½“å‰ç§Ÿæˆ·ID
    admin_user_id = context.user_data.get('admin_user_id')
    
    # ä¿å­˜æˆ–æ›´æ–°Telegramç”¨æˆ·
    tg_user, created = TelegramUser.objects.get_or_create(
        telegram_id=user.id,
        defaults={
            'username': user.username,
            'first_name': user.first_name,
            'last_name': user.last_name
        }
    )
    
    if not created:
        tg_user.username = user.username
        tg_user.first_name = user.first_name
        tg_user.last_name = user.last_name
        tg_user.save()
    
    keyboard = [
        [InlineKeyboardButton("ğŸ å‚ä¸æŠ½å¥–", callback_data='join_lottery')],
        [InlineKeyboardButton("ğŸŠ æˆ‘çš„æŠ½å¥–", callback_data='my_lotteries')],
        [InlineKeyboardButton("â“ å¸®åŠ©", callback_data='help')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        f"ğŸ‘‹ ä½ å¥½ {user.first_name}!\n\n"
        f"æ¬¢è¿ä½¿ç”¨æŠ½å¥–æœºå™¨äºº ğŸ‰\n\n"
        f"è¯·é€‰æ‹©åŠŸèƒ½ï¼š",
        reply_markup=reply_markup
    )


async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æŒ‰é’®å›è°ƒå¤„ç†"""
    query = update.callback_query
    await query.answer()
    
    # è·å–å½“å‰ç§Ÿæˆ·ID
    admin_user_id = context.user_data.get('admin_user_id')
    
    if query.data == 'join_lottery':
        # åªæ˜¾ç¤ºå½“å‰ç§Ÿæˆ·çš„æŠ½å¥–æ´»åŠ¨
        now = timezone.now()
        lotteries = Lottery.objects.filter(
            admin_user_id=admin_user_id,  # å…³é”®ï¼šåªæ˜¾ç¤ºå½“å‰ç§Ÿæˆ·çš„æŠ½å¥–
            status='active',
            start_time__lte=now,
            end_time__gte=now
        )[:5]
        
        if not lotteries:
            await query.edit_message_text("æš‚æ— è¿›è¡Œä¸­çš„æŠ½å¥–æ´»åŠ¨")
            return
        
        keyboard = []
        for lottery in lotteries:
            keyboard.append([
                InlineKeyboardButton(
                    f"ğŸ {lottery.title}",
                    callback_data=f'participate_{lottery.id}'
                )
            ])
        keyboard.append([InlineKeyboardButton("Â« è¿”å›ä¸»èœå•", callback_data='main_menu')])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("è¯·é€‰æ‹©è¦å‚ä¸çš„æŠ½å¥–ï¼š", reply_markup=reply_markup)
    
    elif query.data.startswith('participate_'):
        lottery_id = int(query.data.split('_')[1])
        user = query.from_user
        
        try:
            lottery = Lottery.objects.get(id=lottery_id, admin_user_id=admin_user_id)
            tg_user = TelegramUser.objects.get(telegram_id=user.id)
            
            # æ£€æŸ¥æ˜¯å¦å·²å‚ä¸
            if Participation.objects.filter(lottery=lottery, user=tg_user).exists():
                await query.answer("æ‚¨å·²ç»å‚ä¸è¿‡è¿™ä¸ªæŠ½å¥–äº†ï¼", show_alert=True)
                return
            
            # åˆ›å»ºå‚ä¸è®°å½•
            Participation.objects.create(lottery=lottery, user=tg_user)
            
            await query.answer("å‚ä¸æˆåŠŸï¼ç¥æ‚¨å¥½è¿ ğŸ€", show_alert=True)
            await query.edit_message_text(
                f"âœ… å·²æˆåŠŸå‚ä¸æŠ½å¥–ï¼š{lottery.title}\n\n"
                f"å¼€å¥–æ—¶é—´ï¼š{lottery.end_time.strftime('%Y-%m-%d %H:%M')}\n\n"
                f"ç¥æ‚¨å¥½è¿ï¼ğŸ€"
            )
            
        except Exception as e:
            logger.error(f"å‚ä¸æŠ½å¥–å¤±è´¥: {str(e)}")
            await query.answer("å‚ä¸å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•", show_alert=True)
    
    elif query.data == 'my_lotteries':
        user = query.from_user
        tg_user = TelegramUser.objects.get(telegram_id=user.id)
        
        # åªæ˜¾ç¤ºå½“å‰ç§Ÿæˆ·çš„æŠ½å¥–
        participations = Participation.objects.filter(
            user=tg_user,
            lottery__admin_user_id=admin_user_id  # å…³é”®ï¼šæ•°æ®éš”ç¦»
        ).order_by('-participated_at')[:10]
        
        if not participations:
            await query.edit_message_text("æ‚¨è¿˜æ²¡æœ‰å‚ä¸ä»»ä½•æŠ½å¥–")
            return
        
        text = "æ‚¨å‚ä¸çš„æŠ½å¥–ï¼š\n\n"
        for p in participations:
            text += f"ğŸ {p.lottery.title}\n"
            text += f"   çŠ¶æ€ï¼š{p.lottery.get_status_display()}\n\n"
        
        await query.edit_message_text(text)


async def setup_handlers(application: Application):
    """è®¾ç½®å¤„ç†å™¨"""
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CallbackQueryHandler(button_callback))
    logger.info("Botå¤„ç†å™¨å·²æ³¨å†Œ")
```

### ç¬¬å››æ­¥ï¼šURLè·¯ç”±é…ç½®

```python
# lottery/urls.py

from django.urls import path
from . import webhook_views

urlpatterns = [
    # ... ç°æœ‰è·¯ç”± ...
    
    # Webhookè·¯ç”±
    path('webhook/<str:bot_token>/', webhook_views.telegram_webhook, name='telegram-webhook'),
    path('bot/register-webhook/', webhook_views.register_webhook, name='register-webhook'),
    path('bot/remove-webhook/', webhook_views.remove_webhook, name='remove-webhook'),
]
```

### ç¬¬äº”æ­¥ï¼šå‰ç«¯ç•Œé¢ï¼ˆBoté…ç½®é¡µé¢ï¼‰

```vue
<!-- frontend/src/views/BotSettings.vue -->

<template>
  <div class="bot-settings">
    <el-card>
      <template #header>
        <h2>ğŸ¤– æœºå™¨äººé…ç½®</h2>
      </template>
      
      <el-alert 
        v-if="!botConfig.bot_token" 
        type="info" 
        :closable="false"
        style="margin-bottom: 20px;"
      >
        <template #title>
          <strong>å¦‚ä½•è·å–Bot Tokenï¼Ÿ</strong>
        </template>
        <ol>
          <li>åœ¨Telegramæœç´¢ <code>@BotFather</code></li>
          <li>å‘é€ <code>/newbot</code> åˆ›å»ºæ–°æœºå™¨äºº</li>
          <li>æŒ‰æç¤ºè®¾ç½®æœºå™¨äººåç§°å’Œç”¨æˆ·å</li>
          <li>å¤åˆ¶è·å¾—çš„Tokenï¼Œç²˜è´´åˆ°ä¸‹æ–¹</li>
        </ol>
      </el-alert>
      
      <el-form :model="botConfig" label-width="120px">
        <el-form-item label="Bot Token">
          <el-input 
            v-model="botConfig.bot_token" 
            placeholder="ä¾‹å¦‚ï¼š123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11"
            :disabled="botConfig.webhook_enabled"
          />
        </el-form-item>
        
        <el-form-item label="Webhook URL">
          <el-input 
            v-model="botConfig.webhook_url" 
            placeholder="è‡ªåŠ¨ç”Ÿæˆ"
            disabled
          />
          <div style="color: #909399; font-size: 12px; margin-top: 5px;">
            å°†è‡ªåŠ¨ç”Ÿæˆï¼šhttps://yourdomain.com/api/webhook/{bot_token}/
          </div>
        </el-form-item>
        
        <el-form-item label="çŠ¶æ€">
          <el-tag v-if="botConfig.webhook_enabled" type="success">
            âœ… å·²å¯ç”¨
          </el-tag>
          <el-tag v-else type="info">
            â¸ï¸ æœªå¯ç”¨
          </el-tag>
        </el-form-item>
        
        <el-form-item v-if="botConfig.bot_username" label="æœºå™¨äºº">
          <a 
            :href="`https://t.me/${botConfig.bot_username}`" 
            target="_blank"
          >
            @{{ botConfig.bot_username }}
          </a>
        </el-form-item>
        
        <el-form-item>
          <el-button 
            v-if="!botConfig.webhook_enabled" 
            type="primary" 
            @click="registerWebhook"
            :loading="loading"
          >
            å¯ç”¨æœºå™¨äºº
          </el-button>
          <el-button 
            v-else 
            type="danger" 
            @click="removeWebhook"
            :loading="loading"
          >
            åœç”¨æœºå™¨äºº
          </el-button>
        </el-form-item>
      </el-form>
    </el-card>
  </div>
</template>

<script>
import api from '../api'

export default {
  name: 'BotSettings',
  data() {
    return {
      botConfig: {
        bot_token: '',
        webhook_url: '',
        webhook_enabled: false,
        bot_username: ''
      },
      loading: false
    }
  },
  mounted() {
    this.loadBotConfig()
  },
  methods: {
    async loadBotConfig() {
      try {
        const config = await api.getBotConfig()
        this.botConfig = config
      } catch (error) {
        console.error('åŠ è½½é…ç½®å¤±è´¥:', error)
      }
    },
    
    async registerWebhook() {
      if (!this.botConfig.bot_token) {
        this.$message.error('è¯·å…ˆå¡«å†™Bot Token')
        return
      }
      
      try {
        this.loading = true
        const result = await api.registerWebhook({
          bot_token: this.botConfig.bot_token
        })
        
        this.$message.success('æœºå™¨äººå¯ç”¨æˆåŠŸï¼')
        this.botConfig = result
        
      } catch (error) {
        this.$message.error('å¯ç”¨å¤±è´¥ï¼š' + (error.response?.data?.error || 'è¯·æ£€æŸ¥Tokenæ˜¯å¦æ­£ç¡®'))
      } finally {
        this.loading = false
      }
    },
    
    async removeWebhook() {
      try {
        await this.$confirm('ç¡®å®šè¦åœç”¨æœºå™¨äººå—ï¼Ÿ', 'æç¤º', {
          type: 'warning'
        })
        
        this.loading = true
        await api.removeWebhook()
        
        this.$message.success('æœºå™¨äººå·²åœç”¨')
        this.botConfig.webhook_enabled = false
        
      } catch (error) {
        if (error !== 'cancel') {
          this.$message.error('æ“ä½œå¤±è´¥')
        }
      } finally {
        this.loading = false
      }
    }
  }
}
</script>
```

## ğŸš€ éƒ¨ç½²è¦æ±‚

### å¿…éœ€æ¡ä»¶

1. **å…¬ç½‘åŸŸå**ï¼šä¾‹å¦‚ `yourdomain.com`
2. **SSLè¯ä¹¦**ï¼šTelegramè¦æ±‚HTTPSï¼ˆæ¨èä½¿ç”¨Let's Encryptå…è´¹è¯ä¹¦ï¼‰
3. **Nginxé…ç½®**ï¼šåå‘ä»£ç†åˆ°Django

### Nginxé…ç½®ç¤ºä¾‹

```nginx
server {
    listen 443 ssl;
    server_name yourdomain.com;
    
    ssl_certificate /path/to/fullchain.pem;
    ssl_certificate_key /path/to/privkey.pem;
    
    location /api/webhook/ {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    location /api/ {
        proxy_pass http://127.0.0.1:8000;
    }
    
    location / {
        proxy_pass http://127.0.0.1:8080;  # å‰ç«¯
    }
}
```

## ğŸ“Š å•†ä¸šåŒ–ä¼˜åŠ¿

| ç‰¹æ€§ | è¯´æ˜ | ä»·å€¼ |
|------|------|------|
| **æŒ‰éœ€ä»˜è´¹** | æ ¹æ®æœºå™¨äººæ•°é‡æ”¶è´¹ | ğŸ’° çµæ´»å®šä»· |
| **å¿«é€Ÿä¸Šçº¿** | å®¢æˆ·é…ç½®å³å¯ä½¿ç”¨ | âš¡ é™ä½é—¨æ§› |
| **é›†ä¸­ç®¡ç†** | ç»Ÿä¸€åå°ç®¡ç†æ‰€æœ‰ç§Ÿæˆ· | ğŸ“Š æ˜“äºè¿ç»´ |
| **æ•°æ®éš”ç¦»** | å®Œå…¨ç‹¬ç«‹çš„æ•°æ®ç©ºé—´ | ğŸ”’ å®‰å…¨å¯é  |
| **æ— é™æ‰©å±•** | ç†è®ºä¸Šæ”¯æŒæ— é™ç§Ÿæˆ· | ğŸ“ˆ å¯æ‰©å±•æ€§å¼º |

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **å®‰å…¨æ€§**ï¼š
   - Bot Tokenæ˜¯æ•æ„Ÿä¿¡æ¯ï¼Œéœ€è¦åŠ å¯†å­˜å‚¨
   - å»ºè®®ä½¿ç”¨Djangoçš„`encrypt`å­—æ®µæˆ–ç¯å¢ƒå˜é‡

2. **é™æµ**ï¼š
   - Telegramæœ‰APIè°ƒç”¨é™åˆ¶
   - å»ºè®®å®ç°è¯·æ±‚é˜Ÿåˆ—

3. **ç›‘æ§**ï¼š
   - è®°å½•æ¯ä¸ªç§Ÿæˆ·çš„APIè°ƒç”¨æƒ…å†µ
   - åŠæ—¶å‘ç°å¼‚å¸¸

4. **å¤‡ç”¨æ–¹æ¡ˆ**ï¼š
   - å¦‚æœæ— æ³•ä½¿ç”¨Webhookï¼ˆæ²¡æœ‰åŸŸåï¼‰ï¼Œå¯ä»¥ä½¿ç”¨é•¿è½®è¯¢æ¨¡å¼
   - ä½†éœ€è¦ä¸ºæ¯ä¸ªç§Ÿæˆ·å¯åŠ¨ç‹¬ç«‹è¿›ç¨‹

## ğŸ”„ è¿ç§»æ­¥éª¤

1. âœ… æ•°æ®åº“è¿ç§»ï¼ˆæ·»åŠ UserProfileè¡¨ï¼‰
2. âœ… å®ç°Webhookè§†å›¾
3. âœ… å‰ç«¯æ·»åŠ Boté…ç½®é¡µé¢
4. âœ… æµ‹è¯•å•ä¸ªç§Ÿæˆ·
5. âœ… æµ‹è¯•å¤šä¸ªç§Ÿæˆ·æ•°æ®éš”ç¦»
6. âœ… éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒï¼ˆé…ç½®åŸŸå+SSLï¼‰

## ğŸ’¡ ä¸‹ä¸€æ­¥

æˆ‘å¯ä»¥å¸®æ‚¨ï¼š
1. ç«‹å³å®ç°è¿™ä¸ªæ–¹æ¡ˆçš„ä»£ç 
2. æˆ–è€…å…ˆç”¨Pollingæ¨¡å¼å®ç°ç®€å•ç‰ˆï¼ˆæ— éœ€åŸŸåï¼‰
3. æˆ–è€…è®¨è®ºå…¶ä»–æ–¹æ¡ˆ

æ‚¨å¸Œæœ›å¦‚ä½•è¿›è¡Œï¼Ÿ

